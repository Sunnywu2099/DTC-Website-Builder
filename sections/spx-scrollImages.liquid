<style>
  .scroll-imgs{
      width: 100%;
      height: 100vh; /* 设置为视口高度 */
      background: #000;
      overflow: hidden; /* 隐藏溢出部分 */
  }
  .sticky-wrapper{
      height: 100vh;
      margin: 0 auto;
  }
  #scrolling{
      width: 100%;
      height: 100%;
  }
  @media only screen and (max-width: 1000px){

  }
  @media only screen and (max-width: 768px){

  }
</style>

<div class="scroll-imgs">
  <div class="sticky-wrapper">
    <canvas id="scrolling"></canvas>
  </div>
</div>

<script type="module">
    
    gsap.registerPlugin(ScrollTrigger);

    const canvas = document.getElementById("scrolling");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const context = canvas.getContext("2d");
    const frameCount = 200;
    const img = new Image();
    img.setAttribute('crossOrigin', 'anonymous');
    let index = 0;


    function picFn(index) {
      const paddedIndex = index.toString().padStart(4, '0');
      return `https://cdn.shopify.com/s/files/1/0644/1870/9653/files/${paddedIndex}.jpg`;
    }

    function getObjectFitSize(type = "cover",containerWidth,containerHeight,imgWidth,imgHeight) {
        let radio = 1, // 容器与图片的比例
            sx = 0, // 开始剪切的 x 坐标位置。
            sy = 0, // 开始剪切的 y 坐标位置。
            swidth = imgWidth, // 被剪切图像的宽度。
            sheight = imgHeight, // 被剪切图像的高度。
            x = 0, // 在画布上放置图像的 x 坐标位置。
            y = 0, // 在画布上放置图像的 y 坐标位置。
            width = containerWidth, // 要使用的图像的宽度（伸展或缩小图像）。
            height = containerHeight; // 要使用的图像的高度（伸展或缩小图像）。
        let cWHRatio = containerWidth / containerHeight;
        let iWHRatio = imgWidth / imgHeight;
        if (type === "cover") {
            // cover模式，需要裁剪
            if (iWHRatio >= cWHRatio) {
                // 横图，高先匹配，裁剪宽度
                radio = containerHeight / imgHeight;
                sx = (imgWidth - containerWidth / radio) / 2;
                swidth = containerWidth / radio;
                sheight = imgHeight;
            } else {
                // 竖图，宽先匹配，裁剪高度
                radio = containerWidth / imgWidth;
                sy = (imgHeight - containerHeight / radio) / 2;
                swidth = imgWidth;
                sheight = containerHeight / radio;
            }
        } else if (type === "contain") {
            if (iWHRatio >= cWHRatio) {
                // 横图，宽先匹配，高度自适应
                radio = containerWidth / imgWidth;
                y = (containerHeight - imgHeight * radio) / 2;
                height = imgHeight * radio;
            } else {
                // 竖图，高先匹配，宽度自适应
                radio = containerHeight / imgHeight;
                x = (containerWidth - imgWidth * radio) / 2;
                width = imgWidth * radio;
            }
        }
        return {
            sx,
            sy,
            swidth,
            sheight,
            x,
            y,
            width,
            height,
        };
    }

    const render = function () {
      img.src = picFn(index);
      img.onload = function () {
        context.clearRect(0, 0, canvas.width, canvas.height);

        const imageAspectRatio = img.width / img.height;
        const canvasAspectRatio = canvas.width / canvas.height;

        let renderWidth, renderHeight, x, y;

        if (imageAspectRatio > canvasAspectRatio) {
          renderWidth = canvas.width;
          renderHeight = canvas.width / imageAspectRatio;
          x = 0;
          y = (canvas.height - renderHeight) / 2;
        } else {
          renderHeight = canvas.height;
          renderWidth = canvas.height * imageAspectRatio;
          y = 0;
          x = (canvas.width - renderWidth) / 2;
        }

        const sourceX = 0;
        const sourceY = 0;
        const sourceWidth = img.width;
        const sourceHeight = img.height;
        const destX = 0;
        const destY = 0;
        const destWidth = canvas.width;
        const destHeight = canvas.height;

        const { sx,sy,swidth,sheight,x,y,width,height } = getObjectFitSize('cover',100,100,10,10)
        context.drawImage(sx,sy,swidth,sheight,x,y,width,height);
        {% comment %} context.drawImage(img, 0, 0, canvas.width, canvas.height); {% endcomment %}
      };
    };

    // 使用 ScrollTrigger 实现滚动触发
    ScrollTrigger.create({
      trigger: '.scroll-imgs',
      start: 'top top',
      end: '+=2000',
      markers: false,
      pin: true,
      scrub: 0.1,
        onUpdate: (self) => {
          const percent = self.progress;
          index = Math.min(199, Math.ceil(percent * 199));
          render();
        },
    })

    // 预加载图片
    const preloadImages = () => {
      for (let i = 1; i < frameCount; i++) {
        const img = new Image();
        img.src = picFn(i);
      }
    };

    window.onload = function () {
      preloadImages();
      render();
    };
</script>

{% schema %}
  {
    "name": "SPX Scroll images",
    "settings": [
      {
        "type": "textarea",
        "id": "text",
        "label": "Text"
      }
    ],
  "presets": [
    {
      "name": "SPX Scroll images"
    }
  ]
    
  }
{% endschema %}